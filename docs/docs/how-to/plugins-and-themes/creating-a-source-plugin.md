---
title: "Creating a Source Plugin"
tableOfContentsDepth: 2
---

import { Announcement } from "gatsby-interface"

In this tutorial, you'll create your own source plugin that will gather data from an API. The plugin will source data, optimize remote images, and create foreign key relationships between data sourced by your plugin.

## What is a source plugin?

Source plugins "source" data from remote or local locations into what Gatsby calls [nodes](/docs/reference/graphql-data-layer/node-interface/). This tutorial uses a demo API so that you can see how the data works on both the frontend and backend, but the same principles apply if you would like to source data from another API.

At a high-level, a source plugin:

- Ensures local data is synced with its source and is 100% accurate.
- Creates [nodes](/docs/reference/graphql-data-layer/node-interface/) with accurate media types, human-readable types, and accurate
  [contentDigests](/docs/reference/graphql-data-layer/node-interface/#contentdigest).
- Links nodes & creates relationships between them.
- Lets Gatsby know when nodes are finished sourcing so it can move on to processing them.

A source plugin is a regular npm package. It has a `package.json` file, with optional dependencies, as well as a [`gatsby-node.js`](/docs/reference/config-files/gatsby-node/) file where you implement Gatsby's Node APIs. Read more about [files Gatsby looks for in a plugin](/docs/files-gatsby-looks-for-in-a-plugin/) or [creating a generic plugin](/docs/how-to/plugins-and-themes/creating-a-generic-plugin).

## Why create a source plugin?

Source plugins convert data from any source into a format that Gatsby can process. Your Gatsby site can use several source plugins to combine data in interesting ways.

There may not be [an existing plugin](/plugins/?=gatsby-source) for your data source, so you can create your own.

**Please Note:** If your data is local i.e. on your file system and part of your site's repo, then you generally don't want to create a new source plugin. Instead you want to use [gatsby-source-filesystem](/plugins/gatsby-source-filesystem/) which handles reading and watching files for you. You can then use [transformer plugins](/plugins/?=gatsby-transformer) like [gatsby-transformer-yaml](/plugins/gatsby-transformer-yaml/) to make queryable data from files.

## How to create a source plugin

### Overview

The plugin in this tutorial will source blog posts and authors from the demo API, link the posts and authors, and take image URLs from the posts and optimize them automatically. You'll be able to configure your plugin in your site's `gatsby-config.js` file and write GraphQL queries to access your plugin's data.

This tutorial builds off of an existing Gatsby site and some data. If you want to follow along with this tutorial, you can find the codebase inside [the examples folder of the Gatsby repository](https://github.com/gatsbyjs/gatsby/tree/master/examples/creating-source-plugins). Once you clone this code, make sure to delete the `source-plugin` and `example-site` folders. Otherwise, the tutorial steps will already be completed.

#### An example API request

To see the API in action, you can run it locally by navigating into the `api` folder, installing dependencies with `npm install`, and starting the server with `npm start`. You will then be able to navigate to a GraphQL playground running at `http://localhost:4000`. This is a GraphQL server running in Node.js and is _separate from Gatsby_, this server could be replaced with a different backend or data source and the patterns in this tutorial would remain the same. Other possible examples could be a REST API, local files, or even a database, so long as you can access data it can be sourced.

If you paste the following query into the left side of the window and press the play button, you should see data for posts with their IDs and descriptions returned:

```graphql
query {
  posts {
    id
    description
  }
}
```

This data is an example of the data you will source with your plugin.

#### Plugin behavior

Your plugin will have the following behavior:

- Make an API request to the demo API.
- Convert the data in the API response to Gatsby's node system.
- Link the nodes together so you can query for an author on each post.
- Accept plugin options to customize how your plugin works.
- Optimize images from Unsplash URLs so they can be used with `gatsby-image`.

### Set up projects for plugin development

You'll need to set up an example site and create a plugin inside it to begin building.

#### Set up an example site

Create a new Gatsby site with the `gatsby new` command, based on the hello world starter.

```shell
gatsby new example-site https://github.com/gatsbyjs/gatsby-starter-hello-world
```

This site generated by the `new` command is where the plugin will be installed, giving you a place to test the code for your plugin.

#### Set up a source plugin

Create a new Gatsby plugin with the `gatsby new` command, this time based on the plugin starter.

```shell
gatsby new source-plugin https://github.com/gatsbyjs/gatsby-starter-plugin
```

This will create your plugin in a separate project from your example site, but you could also include it in your site's [`plugins` folder](/docs/loading-plugins-from-your-local-plugins-folder/).

Your plugin starts with a few files from the starter, which can be seen in the snippet below:

```text
/example-site
/source-plugin
├── .gitignore
├── gatsby-browser.js
├── gatsby-node.js
├── gatsby-ssr.js
├── index.js
├── package.json
└── README.md
```

The biggest changes will be in **`gatsby-node.js`**. This file is where Gatsby expects to find any usage of the [Gatsby Node APIs](/docs/reference/config-files/gatsby-node/). These allow customization/extension of default Gatsby settings affecting pieces of the site build process. All the logic for sourcing data will live in this file.

#### Install your plugin in the example site

You need to install your plugin in the site to be able to test that your code is running. Gatsby only knows to run plugins that are included in its `gatsby-config.js` file. Open up the `gatsby-config.js` file in the `example-site` and [add your plugin using `require.resolve`](/docs/creating-a-local-plugin/#using-requireresolve-and-a-filepath). If you decide to publish your plugin it can be installed with an `npm install <plugin-name>` and including the name of the plugin in the config instead of `require.resolve`.

```javascript:title=example-site/gatsby-config.js
module.exports = {
  plugins: [require.resolve(`../source-plugin`)],
}
```

_You can include the plugin by using its name if you are using [npm link or yarn workspaces](/docs/creating-a-local-plugin/#using-npm-link-or-yarn-link) or place your `source-plugin` in [`example-site/plugins`](/docs/creating-a-local-plugin/) instead of being in a folder a step above and using `require.resolve`._

You can now navigate into the `example-site` folder and run `gatsby develop`. You should see a line in the output in the terminal that shows your plugin loaded:

```shell:title=example-site
$ gatsby develop
success open and validate gatsby-configs - 0.033s
success load plugins - 0.074s
Loaded gatsby-starter-plugin // highlight-line
success onPreInit - 0.016s
...
```

If you open the `gatsby-node.js` file in your `source-plugin` folder, you will see the `console.log` that produces that output in the terminal.

```javascript:title=source-plugin/gatsby-node.js
exports.onPreInit = () => console.log("Loaded gatsby-starter-plugin")
```

### Source data and create nodes

Data is sourced in the `gatsby-node.js` file of source plugins or Gatsby sites. Specifically, it's done by calling a Gatsby function called `createNode` inside of the `sourceNodes` API in the `gatsby-node.js` file.

#### Create nodes inside of `sourceNodes` with the `createNode` function

Open up the `gatsby-node.js` file in the `source-plugin` project and add the following code to create nodes from a hardcoded array of data :

```javascript:title=source-plugin/gatsby-node.js
// constants for your GraphQL Post and Author types
const POST_NODE_TYPE = `Post`

exports.sourceNodes = async ({
  actions,
  createContentDigest,
  createNodeId,
  getNodesByType,
}) => {
  const { createNode } = actions

  const data = {
    posts: [
      { id: 1, description: `Hello world!` },
      { id: 2, description: `Second post!` },
    ],
  }

  // loop through data and create Gatsby nodes
  data.posts.forEach(post =>
    createNode({
      ...post,
      id: createNodeId(`${POST_NODE_TYPE}-${post.id}`),
      parent: null,
      children: [],
      internal: {
        type: POST_NODE_TYPE,
        content: JSON.stringify(post),
        contentDigest: createContentDigest(post),
      },
    })
  )

  return
}
```

This code creates Gatsby nodes that are queryable in a site. The following bullets break down what is happening in the code:

- You implemented Gatsby's [`sourceNodes` API](/docs/reference/config-files/gatsby-node/#sourceNodes), which Gatsby will run as part of its bootstrap process, and pulled out some Gatsby helpers (like `createContentDigest` and `createNodeId`) to facilitate creating nodes.
- You provided the required fields for the node like creating a node ID and a content digest (which Gatsby uses to track dirty nodes—or nodes that have changed). The content digest should include the whole content of the item (`post`, in this case).
- Then you stored some data in an array and looped through it, calling `createNode` on each post in the array.

If you run the `example-site` with `gatsby develop`, you can now open up `http://localhost:8000/___graphql` and query your posts with this query:

```graphql
query {
  allPost {
    nodes {
      id
      description
    }
  }
}
```

The problem with this data is that it is _not coming from the API_, it is hardcoded into an array. The declaration of the `data` array needs to be updated to pull data from a different location.

### Caching data between runs

Some operations like fetching data from an endpoint can be performance heavy or time-intensive. In order to improve the experience of developing with your source plugin, you can leverage the Gatsby cache to store data between runs of `gatsby develop` or `gatsby build`.

You access the `cache` in Gatsby Node APIs and use the `set` and `get` functions to store and retrieve data as JSON objects.

```javascript:title=source-plugin/gatsby-node.js
exports.onPostBuild = async ({ cache }) => {
  await cache.set(`key`, `value`)
  const cachedValue = await cache.get(`key`)
  console.log(cachedValue) // logs `value`
}
```

The above snippet shows a contrived example for the `cache`, but it can be used in more sophisticated cases to reduce the time it takes to run your plugin. For example, by caching a timestamp, you can use it to fetch solely the data that has been updated since the last time data was fetched from the source:

```javascript:title=source-plugin/gatsby-node.js
exports.sourceNodes = async ({ cache }) => {
  // get the last timestamp from the cache
  const lastFetched = await cache.get(`timestamp`)

  // pull data from some remote source using cached data as an option in the request
  const data = await fetch(
    `https://remotedatasource.com/posts?lastUpdated=${lastFetched}`
  )
  // ...
}

exports.onPostBuild = async ({ cache }) => {
  // set a timestamp at the end of the build
  await cache.set(`timestamp`, Date.now())
}
```

This can reduce the time it takes repeated data fetching operations to run if you are pulling in large amounts of data for your plugin. Existing plugins like [`gatsby-source-contentful`](https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-contentful/src/gatsby-node.js) generate a token that is sent with each request to only return new data.

You can read more about the cache API, other types of plugins that leverage the cache, and example open source plugins that use the cache in the [build caching guide](/docs/build-caching).

### Querying and sourcing data from a remote location

You can query data from any location to source at build time using functions and libraries like Node.js's built-in `http.get`, `axios`, or `node-fetch`. This tutorial uses a GraphQL client so that the source plugin can support GraphQL subscriptions when it fetches data from the demo API, and can proactively update your data in the site when information on the API changes.

#### Adding dependencies

You'll use several modules from npm to making fetching data with GraphQL easier. Install them in the `source-plugin` project with:

```shell:title=source-plugin
npm install @apollo/client graphql subscriptions-transport-ws ws
```

_Note: The libraries used here are specifically chosen so that the source plugin can support [GraphQL subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/). You can fetch data the same way you would in any other Node.js app or however you are most comfortable._

Open your `package.json` file after installation and you'll see the packages have been added to a `dependencies` section at the end of the file.

#### Configure an Apollo client to fetch data

Import the handful of Apollo packages that you installed to help set up an Apollo client in your plugin:

```javascript:title=source-plugin/gatsby-node.js
// highlight-start
const { ApolloClient, InMemoryCache, gql, split, HttpLink } = require("@apollo/client")
const { WebSocketLink } = require("@apollo/client/link/ws")
const { getMainDefinition } = require("@apollo/client/utilities")
const WebSocket = require("ws")
const fetch = require("node-fetch")
// highlight-end

const POST_NODE_TYPE = `Post`

exports.sourceNodes = async ({
// ...
```

Then you can copy this code that sets up the necessary pieces of the Apollo client and paste it after your imports:

```javascript:title=source-plugin/gatsby-node.js
// ... imports
const WebSocket = require("ws")

const POST_NODE_TYPE = `Post`

// highlight-start
const client = new ApolloClient({
  link: split(
    ({ query }) => {
      const definition = getMainDefinition(query)
      return (
        definition.kind === "OperationDefinition" &&
        definition.operation === "subscription"
      )
    },
    new WebSocketLink({
      uri: `ws://localhost:4000`, // or `ws://gatsby-source-plugin-api.glitch.me/`
      options: {
        reconnect: true,
      },
      webSocketImpl: WebSocket,
    }),
    new HttpLink({
      uri: "http://localhost:4000", // or `https://gatsby-source-plugin-api.glitch.me/`
      fetch,
    })
  ),
  cache: new InMemoryCache(),
})
// highlight-end

exports.sourceNodes = async ({
// ...
```

You can read about each of the packages that are working together in [Apollo's docs](https://www.apollographql.com/docs/react/). The end result is creating a `client` that you can use to call methods like `query` to get data from the source it's configured to work with. In this case, that is `http://localhost:4000` where you should have the API running.

#### Query data from the API

Now you can replace the hardcoded data in the `sourceNodes` function with a GraphQL query:

```diff:title=source-plugin/gatsby-node.js
  exports.sourceNodes = async ({
    actions,
    createContentDigest,
    createNodeId,
    getNodesByType,
  }) => {
    const { createNode, touchNode, deleteNode } = actions

-   const data = {
-     posts: [
-       { id: 1, description: `Hello world!` },
-       { id: 2, description: `Second post!` },
-     ],
-   }
+   const { data } = await client.query({
+     query: gql`
+       query {
+         posts {
+           id
+           description
+         }
+       }
+     `,
+   })

    // ...
```

Now you're creating nodes based on data coming from the API. Neat! However, only the `id` and `description` fields are coming back from the API and being saved to each node, so add the rest of the fields to the query so that the same data is available to Gatsby.

This is also a good time to add data to your query so that it also returns authors.

```javascript:title=source-plugin/gatsby-node.js
const { data } = await client.query({
  query: gql`
    query {
      posts {
        id
        description
        // highlight-start
        slug
        imgUrl
        imgAlt
        author {
          id
          name
        }
      }
      authors {
        id
        name
      }
      // highlight-end
    }
  `,
})
```

With the new data, you can also loop through the authors to create Gatsby nodes from them by adding another loop to `sourceNodes`:

```javascript:title=source-plugin/gatsby-node.js
const POST_NODE_TYPE = `Post`
const AUTHOR_NODE_TYPE = `Author` // highlight-line

exports.sourceNodes = async ({
  actions,
  createContentDigest,
  createNodeId,
  getNodesByType,
}) => {
  const { createNode, touchNode, deleteNode } = actions

  const { data } = await client.query({
    query: gql`
      query {
        posts {
          id
          slug
          description
          imgUrl
          imgAlt
          author {
            id
            name
          }
        }
        authors {
          id
          name
        }
      }
    `,
  })

  // loop through data returned from the api and create Gatsby nodes for them
  data.posts.forEach(post =>
    createNode({
      ...post,
      id: createNodeId(`${POST_NODE_TYPE}-${post.id}`), // hashes the inputs into an ID
      parent: null,
      children: [],
      internal: {
        type: POST_NODE_TYPE,
        content: JSON.stringify(post),
        contentDigest: createContentDigest(post),
      },
    })
  )
  // highlight-start
  data.authors.forEach(author =>
    createNode({
      ...author,
      id: createNodeId(`${AUTHOR_NODE_TYPE}-${author.id}`), // hashes the inputs into an ID
      parent: null,
      children: [],
      internal: {
        type: AUTHOR_NODE_TYPE,
        content: JSON.stringify(author),
        contentDigest: createContentDigest(author),
      },
    })
  )
  // highlight-end

  return
}
```

At this point you should be able to run `gatsby develop` in your `example-site`, open up GraphiQL at `http://localhost:8000/___graphql` and query both posts and authors.

```graphql
query {
  allPost {
    nodes {
      id
      description
      imgUrl
    }
  }
  allAuthor {
    nodes {
      id
      name
    }
  }
}
```

### Working with data received from remote sources

#### Setting media and MIME types

Each node created by the filesystem source plugin includes the raw content of the file and its _media type_.

A [**media type**](https://en.wikipedia.org/wiki/Media_type) (also **MIME type** and **content type**) is an official way to identify the format of files/content that are transmitted via the internet, e.g. over HTTP or through email. You might be familiar with other media types such as `application/javascript`, `audio/mpeg`, `text/html`, etc.

Each source plugin is responsible for setting the media type for the nodes it creates. This way, source and transformer plugins can work together easily.

This is not a required field -- if it's not provided, Gatsby will [infer](/docs/glossary#inference) the type from data that is sent -- but it's how source plugins indicate to transformers that there is "raw" data the transformer can further process.

It also allows plugins to remain small and focused. Source plugins don't have to have opinions on how to transform their data: they can set the `mediaType` and push that responsibility to transformer plugins instead.

For example, it's common for services to allow you to add content in Markdown format. If you pull that Markdown into Gatsby and create a new node, what then? How would a user of your source plugin convert that Markdown into HTML they can use in their site? You would create a node for the Markdown content and set its `mediaType` as `text/markdown` and the various Gatsby Markdown transformer plugins would see your node and transform it into HTML.

This loose coupling between the data source and the transformer plugins allow Gatsby site builders to assemble complex data transformation pipelines with little work on their (and your (the source plugin author)) part.

### Optimize remote images

Each node of post data has an `imgUrl` field with the URL of an image on Unsplash. You could use that URL to load images on your site, but they will be large and take a long time to load. You can optimize the images with your source plugin so that a site using your plugin already has data for `gatsby-plugin-image` ready to go!

You can read about [how to use the Gatsby Image plugin](/docs/how-to/images-and-media/using-gatsby-plugin-image/) if you are unfamiliar with it.

#### Create remote file node from a URL

To create optimized images from URLs, `File` nodes for image files need to be added to your site's data. Then, you can install `gatsby-plugin-sharp` and `gatsby-transformer-sharp` which will automatically find image files and add the data needed for `gatsby-plugin-image`.

Start by installing `gatsby-source-filesystem` in the `source-plugin` project:

```shell:title=source-plugin
npm install gatsby-source-filesystem
```

Now in your plugin's `gatsby-node.js` file, you can implement a new API, called `onCreateNode`, that gets called every time a node is created. You can check if the node created was one of your `Post` nodes, and if it was, create a file from the URL on the `imgUrl` field.

Import the `createRemoteFileNode` helper from `gatsby-source-filesystem`, which will download a file from a remote location and create a `File` node for you.

```javascript:title=source-plugin/gatsby-node.js
const { ApolloClient } = require("apollo-client")
const { InMemoryCache } = require("apollo-cache-inmemory")
const { split } = require("apollo-link")
const { HttpLink } = require("apollo-link-http")
const { WebSocketLink } = require("apollo-link-ws")
const { getMainDefinition } = require("apollo-utilities")
const fetch = require("node-fetch")
const gql = require("graphql-tag")
const WebSocket = require("ws")
// highlight-start
const { createRemoteFileNode } = require(`gatsby-source-filesystem`)
// highlight-end
```

Then export a new function `onCreateNode`, and call `createRemoteFileNode` in it whenever a node of type `Post` is created:

```javascript:title=source-plugin/gatsby-node.js
// called each time a node is created
exports.onCreateNode = async ({
  node, // the node that was just created
  actions: { createNode, createNodeField },
  createNodeId,
  getCache,
}) => {
  if (node.internal.type === POST_NODE_TYPE) {
    const fileNode = await createRemoteFileNode({
      // the url of the remote image to generate a node for
      url: node.imgUrl,
      parentNodeId: node.id,
      createNode,
      createNodeId,
      getCache,
    })

    if (fileNode) {
      createNodeField({ node, name: 'localFile', value: fileNode.id })
    }
  }
}
```

This code is called every time a node is created, e.g. when `createNode` is invoked. Each time it is called in the `sourceNodes` step, the condition will check if the node was a `Post` node. Since those are the only nodes with an image associated with them, that is the only time images need to be optimized. Then a remote node is created, if it's successful, the `fileNode` is returned. The next few lines are important:

```javascript:title=source-plugin/gatsby-node.js
if (fileNode) {
  createNodeField({ node, name: 'localFile', value: fileNode.id })
}
```

By using [`createNodeField`](/docs/reference/config-files/actions/#createNodeField) you're extending the existing node and place a new field named `localFile` under the `fields` key.

<Announcement style={{marginBottom: "1.5rem"}}>

**Note:** Do not mutate the `node` directly and use `createNodeField` instead. Otherwise the change won't be persisted and you might see inconsistent data. This behavior changed with Gatsby 4, read the [migration guide](/docs/reference/release-notes/migrating-from-v3-to-v4/#dont-mutate-nodes-outside-of-expected-apis) to learn more.

</Announcement>

In the previous step you only defined the `fileNode.id` as a `value` but at this time Gatsby can't just yet resolve this to the `fileNode` (and susequently the image) itself. Therefore, you'll need to create a foreign-key relationship between the `Post` node and the respective `File` node. Use the [`createSchemaCustomization`](/docs/reference/config-files/gatsby-node/#createSchemaCustomization) API to define this relationship:

```javascript:title=source-plugin/gatsby-node.js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions

  createTypes(`
    type Post implements Node {
      localFile: File @link(from: "fields.localFile")
    }
  `)
}
```

**Note**: You can use [schema customization APIs](/docs/reference/graphql-data-layer/schema-customization/#foreign-key-fields) to create these kinds of connections between nodes as well as sturdier and more strictly typed ones.

You now can query the image like this:

```graphql
query {
  allPost {
    nodes {
      id
      localFile {
        id
        relativePath
      }
    }
  }
}
```

At this point you have created local image files from the remote locations and associated them with your posts, but you still need to transform the files into optimized versions.

#### Transform `File` nodes with sharp plugins

sharp plugins make optimization of images possible at build time.

Install `gatsby-plugin-sharp`, `gatsby-plugin-image`, and `gatsby-transformer-sharp` in the `example-site` (_not_ the plugin):

```shell:title=example-site
npm install gatsby-plugin-sharp gatsby-transformer-sharp gatsby-plugin-image
```

Then include the plugins in your `gatsby-config`:

```javascript:title=example-site/gatsby-config.js
module.exports = {
  plugins: [
    require.resolve(`../source-plugin`),
    // highlight-start
    `gatsby-plugin-image`,
    `gatsby-plugin-sharp`,
    `gatsby-transformer-sharp`,
    // highlight-end
  ],
}
```

By installing the sharp plugins in the site, they'll run after the source plugin and transform the file nodes and add fields for the optimized versions at `childImageSharp`. The transformer plugin looks for `File` nodes with extensions like `.jpg` and `.png` to create optimized images and creates the GraphQL fields for you.

Now when you run your site, you will also be able to query a `childImageSharp` field on the `post.localFile`:

```graphql
query {
  allPost {
    nodes {
      localFile {
        // highlight-start
        childImageSharp {
          gatsbyImageData
        }
        // highlight-end
      }
    }
  }
}
```

With data available, you can now query optimized images to use with the `gatsby-plugin-image` component in a site!

### Create foreign key relationships between data

To link the posts to the authors, Gatsby needs to be aware that the two are associated, and how. You have already implemented one example of this when Gatsby inferred a connection between a `localFile` and the remote file from Unsplash.

The best approach for connecting related data is through customizing the GraphQL schema. By implementing the `createSchemaCustomization` API, you can specify the exact shape of a node's data. While defining that shape, you can optionally link a node to other nodes to create a relationship.

Copy this code and add it to the `source-plugin` in the `gatsby-node.js` file:

```javascript:title=source-plugin/gatsby-node.js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  createTypes(`
    type Post implements Node {
      id: ID!
      slug: String!
      description: String!
      imgUrl: String!
      imgAlt: String!
      # create relationships between Post and Author nodes
      author: Author @link(from: "author.name" by: "name")
      # Created in previous step
      localFile: @link(from: "fields.localFile")
    }
    type Author implements Node {
      id: ID!
      name: String!
    }
  `)
}
```

The `author: Author @link(from: "author.name" by: "name")` line tells Gatsby to look for the value on the `Post` node at `post.author.name` and relate it with an `Author` node with a matching `name`. This demonstrates the ability to link using more than just an ID.

Now running the site will allow you to query authors from the post nodes!

```graphql
query {
  allPost {
    nodes {
      id
      // highlight-start
      author {
        name
      }
      // highlight-end
    }
  }
}
```

### Using data from the source plugin in a site

In the `example-site`, you can now query data from pages.

Add a file at `example-site/src/pages/index.js` and copy the following code into it:

```jsx:title=example-site/src/pages/index.js
import React from "react"
import { graphql } from "gatsby"
import { GatsbyImage } from "gatsby-plugin-image"

export default ({ data }) => (
  <>
    <h1>Posts</h1>
    <section
      style={{
        display: `grid`,
        gridTemplateColumns: `repeat( auto-fit, minmax(250px, 1fr) )`,
        gridGap: 16,
      }}
    >
      {data.allPost.nodes.map(post => (
        <div
          style={{
            display: `flex`,
            flexDirection: `column`,
            padding: 16,
            border: `1px solid #ccc`,
          }}
        >
          <h2>{post.slug}</h2>
          <span>By: {post.author.name}</span>
          <p>{post.description}</p>
          <GatsbyImage
            image={post.localFile?.childImageSharp?.gatsbyImageData}
            alt={post.imgAlt}
          />
        </div>
      ))}
    </section>
  </>
)

export const query = graphql`
  {
    allPost {
      nodes {
        id
        slug
        description
        imgAlt
        author {
          id
          name
        }
        localFile {
          childImageSharp {
            gatsbyImageData(formats: [AUTO, WEBP, AVIF])
          }
        }
      }
    }
  }
`
```

This code uses a [page query](/docs/how-to/querying-data/page-query/) to fetch all posts and provide them to the component in the `data` prop at build time. The JSX code loops through the posts so they can be rendered to the DOM.

### Using plugin options to customize plugin usage

You can pass options into a plugin through a `gatsby-config.js` file. Update the code where your plugin is installed in the `example-site`, changing it from a string, to an object with a `resolve` and `options` key.

```javascript:title=example-site/gatsby-config.js
module.exports = {
  plugins: [
    // highlight-start
    {
      resolve: require.resolve(`../source-plugin`),
      options: {
        previewMode: true,
      },
    },
    // highlight-end
    `gatsby-plugin-sharp`,
    `gatsby-transformer-sharp`,
  ],
}
```

Now the options you designated (like `previewMode: true`) will be passed into each of the Gatsby Node APIs like `sourceNodes`, making options accessible inside of Gatsby APIs. Add an argument called `pluginOptions` to your `sourceNodes` function.

```javascript:title=source-plugin/gatsby-node.js
exports.sourceNodes = async (
  { actions, createContentDigest, createNodeId, getNodesByType },
  pluginOptions // highlight-line
) => {
  const { createNode, touchNode, deleteNode } = actions
  // highlight-start
  console.log(pluginOptions.previewMode) // true
  // highlight-end

  // ... other code removed for brevity
}
```

Options can be a good way of providing conditional paths to logic that you as a plugin author want to provide or limit. Read the [Configuring Plugin usage with Plugin Options](/docs/how-to/plugins-and-themes/configuring-usage-with-plugin-options/) guide to learn how to add validation to your plugin options.

### Improve plugin developer experience by enabling faster sync

One challenge when developing locally is that a developer might make modifications in a remote data source, like a CMS, and then want to see how it looks in the local environment. Typically they will have to restart the `gatsby develop` server to see changes. In order to improve the development experience of using a plugin, you can reduce the time it takes to sync between Gatsby and the data source by enabling faster synchronization of data changes. The best way to do this is by adding **event-based syncing**.

Some data sources keep event logs and are able to return a list of objects modified since a given time. If you're building a source plugin, you can store the last time you fetched data using the [cache](/docs/creating-a-source-plugin/#caching-data-between-runs) and then only sync down nodes that have been modified since that time. [`gatsby-source-contentful`](https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-source-contentful) is an example of a source plugin that does this.

## Publishing a plugin

Don't publish this particular plugin to npm or the Gatsby Plugin Library, because it's just a sample plugin for the tutorial. However, if you've built a local plugin for your project, and want to share it with others, npm allows you to publish your plugins. Check out the npm docs on [How to Publish & Update a Package](https://docs.npmjs.com/getting-started/publishing-npm-packages) for more info.

**Please Note:** Once you have published your plugin on npm, don't forget to edit your plugin's `package.json` file to include info about your plugin. If you'd like to publish a plugin to the [Gatsby Plugin Library](/plugins/) (please do!), please [follow these steps](/docs/how-to/plugins-and-themes/submit-to-plugin-library/).

## Summary

You've written a Gatsby plugin that:

- can be configured with an entry in your `gatsby-config.js` file
- requests data from an API
- pulls the API data into Gatsby's node system
- allows the data to be queried with GraphQL
- optimizes images from a remote location automatically
- links data types with a customized GraphQL schema
- updates new data without needing to restart your Gatsby site

Congratulations!

## Additional resources

- [Example repository](https://github.com/gatsbyjs/gatsby/tree/master/examples/creating-source-plugins) with all of this code implemented
